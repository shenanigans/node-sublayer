
var http = require ('http');
var https = require ('https');
var async = require ('async');
var filth = require ('filth');
var likeness = require ('likeness');

/**     @class substation.Action
    @root
    Wraps a reaction function with its html templates, input schemata, minimum authentication
    requirements and other minor configuration options to create a multi-transport handler.
@argument/.Configuration config
    @optional
    Specify templates, input schemata, minimum authentication requirements, and other options.
@callback/Function reaction
    The reaction function, i.e. the working business logic being served by `substation` at a given
    url-matching expression and request method.

    @argument/Array[String] params
        Selecting groups in the url, filled by the request url provided by the user.
    @argument/substation.AuthenticationStatus auth
        Specifies the current authentication level of the user accessing this Action.
    @argument/Reply reply
*/
function Action (domain, keyHash, config) {
    this.domain = domain;
    this.keyHash = keyHash;
    this.config = filth.clone (DEFAULT_CONFIG);
    filth.merge (this.config, config);

    if (this.config.route)
        this.route = new RegExp (this.config.route);
    if (this.config.method)
        this.method = this.config.method;
}


/**     @class Configuration
@member/String|RegExp|undefined route
    As an alternative to setting the route [when activating the Action](substation#addAction) you
    may set it in the configuration. Routes specified in `addAction` override configured routes.

    When a route is set as a String, it is prepended with a forward slash if none is present and
    converted to a regular expression of the form `/pathname(?:/(.*))?`.
@member/Object|Function|undefined template
    Define one or more template Functions to convert a context Object to an html string. If a
    Function is used, all html responses are generated by this Function. If an Object is provided,
    http response codes are mapped to templates. If a response code cannot be matched exactly, it
    falls back to the `200` template, then attemps an exact match and finally the `200` template on
    the [global templates](substation.Configuration#template).

    Template Functions may be synchronous or asynchronous. The context Object and a callback
    Function are passed as arguments.
@member/Object|undefined context
    When generating html with a template but never when generating a JSON response, [response
    content](substation.Response#content) is non-destructively deep-merged over this Object. To put
    it another way, `context` sets default content for html pages.
@member/Function|undefined setup
    Called during the parent server's initialization stage, before the server has begun accepting
    requests. It's usually the best time to establish database access. Two arguments are passed:
     * [Object]() `configuration` The Action's configuration Object. You may still edit the
        configuration at this point.
     * [Function]() `callback` Call when the Action is ready to use.
@member/JSON authentication
    @property/Boolean Authentication.isLoggedIn
        @default `false`
        Require that the Agent be logged into the application to use access this Action.
    @property/Boolean Authentication.isDomestic
        @default `false`
        Require that the Agent have same-origin access priveleges in the client context to use this
        Action. This secures against XSS attacks in the browser.
    @property/Boolean Authentication.allowGuests
        @default `true`
        Requires that an Agent be at least an Idle Agent to use this Action. An Idle Agent is one
        that presents an expired session token. It is possible for an Idle Agent to be Domestic.
@member/Object bodySchema
    A JSON Schema document used to restrict request body content. filth form requests are mapped
    to simple flat Objects and JSON bodies are validated as-are. Failure to validate will cause a
    `406` response to be automatically sent. When `bodySchema` is present, an Action's
    `request.body` can always be assumed to conform. Finally, the parent server will automatically
    respond to OPTIONS requests with `{ VERB:{ body:bodySchema, query:querySchema }, ...`.

    Schemata are pre-compiled with [likeness](https://github.com/shenanigans/node-likeness) for
    rapid validation. This allows `$ref` to validate much more quickly, however, it will load
    references when the server starts and does not keep them up to date (yet).
@member/Object querySchema
    A JSON Schema document used to restrict request url query terms. The query is mapped as a simple
    flat Object and the field `_domestic` is automatically stripped before validation. Failure to
    validate will cause a `406` response to be automatically sent. When `querySchema` is present, an
    Action's `request.query` can always be assumed to conform. The parent server will automatically
    respond to OPTIONS requests with `{ VERB:{ body:bodySchema, query:querySchema }, ...`.

    Schemata are pre-compiled with [likeness](https://github.com/shenanigans/node-likeness) for
    rapid validation. This allows `$ref` to validate much more quickly, however, it will load
    references when the server starts and does not keep them up to date (yet).
*/

var proxyReplySchema = new likeness ({
    status:         {
        '.type':        'string',
        '.length':      3,
        '.error':       'invalid status string'
    },
    events:         {
        '.type':        'array',
        '.optional':    true,
        '.maxVals':     128,
        '.error':       'invalid event list',
        '.each':        {
            '.type':        'array',
            '.sequence':    [ { '.type':'string', '.maxLength':128 } ],
            '.extras':      { '.arbitrary':true },
            '.error':       'invalid event'
        }
    },
    content:        {
        '.type':        'object',
        '.optional':    true,
        '.arbitrary':   true,
        '.error':       'invalid content'
    }
});

/**     @member/Function run
    Try to perform this [Action](substation.Action) as a given Agent using a particular [Request]
    (.Request) and wrap the result in a [Reply.](.Reply). Subject to immediate failure conditions
    if the [body](.Configuration#bodySchema) or [query](.Configuration#querySchema) fail schema
    validation, if the agent is not [sufficiently authenticated](.Configuration#authentication),
    if the body's content-type is [not acceptable](.Configuration#binaryStreams), or if the reaction
    Function synchronously throws an [Error](). Error conditions are routed through the templates
    by the http codes `403` and `406`.
@argument/substation station
    The [substation]() instance managing this request.
@argument/substation.Agent agent
    Authentication manager for the requesting user and their device. Used to view or change the
    User's login status.
@argument/.Request request
    Details of the request. The `request` Object is consistent across network transports to help
    similar requests be holistically similar.
@argument/substation.Action.Reply reply
    Return a JSON body document associated with the request, automatically rendered by templates
    when required, and/or emit events on the client device that are not associated with the request
    in any way. Events emitted by a `reply` are not distinct from those produced by
    [station.sendEvent](substation#sendEvent).
*/
Action.prototype.run = function (station, agent, request, reply) {
    var self = this;
    var options = filth.clone (this.config.forward);

    if (this.bodySchema) {
        var done = false;
        var reaction = this.reaction;
        try {
            this.bodySchema.validate (request.body);
        } catch (err) {
            reply.content ({ SchemaError:err });
            self.parent.logger.warn ('body error');
            reply.done (400);
            return;
        }
    }

    if (this.querySchema) {
        var done = false;
        var reaction = this.reaction;
        try {
            this.bodySchema.validate (request.query);
        } catch (err) {
            reply.content ({ SchemaError:err });
            self.parent.logger.warn ('query error');
            reply.done (400);
            return;
        }
    }

    var tech;
    if (!this.config.tls)
        tech = http;
    else {
        tech = https;
        if (this.config.tls instanceof Buffer)
            options.cert = this.config.tls;
    }
    var remoteRequest = tech.request (options, function (response) {
        // api key matches?
        if (response.headers['x-substation-key'] != self.keyHash) {
            station.logger.warn (
                { hash:response.headers['x-substation-key'] },
                'response contained invalid api key hash'
            );
            reply.done (502);
            response.emit ('end');
            return;
        }

        var actionStatus = response.headers['x-substation-status'] || response.statusCode;

        var total = 0;
        var chunks = [];
        function finalize(){
            if (response.headers.location)
                reply.redirectURL = response.headers.location;

            // html requests stream
            if (request.format == 'html') {
                response.on ('data', function (chunk) {
                    total += chunk.length;
                    if (total > self.config.maxResponseLength)
                        // cancel this response
                        response.emit ('end');
                });
                reply.stream (
                    actionStatus,
                    response,
                    response.headers['content-length'],
                    'text/html'
                );
                return;
            }

            response.on ('data', function (chunk) {
                total += chunk.length;
                if (total > self.config.maxResponseLength) {
                    // cancel this response
                    response.removeAllListeners();
                    response.emit ('end');
                    return;
                }
                chunks.push (chunk);
            });
            response.on ('end', function(){
                var replyString = Buffer.concat (chunks).toString();
                try {
                    var replyDoc = JSON.parse (replyString);
                    proxyReplySchema.validate (replyDoc);
                } catch (err) {
                    // response was invalid json
                    station.logger.warn ({
                        err:        err,
                        domain:     self.domain,
                        action:     self.name,
                        forward:    self.config.forward
                    }, 'invalid proxy response');
                    return reply.done (502);
                }

                if (replyDoc.events)
                    reply.sendEvents (replyDoc.events);
                if (replyDoc.content)
                    reply.content (replyDoc.content);
                reply.done (actionStatus);
            });
            response.on ('error', function (err) {
                station.logger.warn ({
                    domain:     self.domain,
                    action:     self.name,
                    forward:    self.config.forward
                }, 'proxy response failed');
                reply.content ({ ServerError:err });
                return reply.done (502);
            });
        }

        // auth changes?
        if (response.headers['x-substation-agent-status']) {
            var user = response.headers['x-substation-user'];
            var client = response.headers['x-substation-client'];
            var agentStatus = response.headers['x-substation-agent-status'];
            var rememberMe = Boolean (response.headers['x-substation-remember-me']);

            var callName;
            if (agentStatus == 'logout') {
                agent.logout (client, finalize);
                return;
            }
            if (agentStatus == 'active')
                callName = 'setActive';
            else if (agentStatus == 'idle')
                callName = 'setIdle';
            else {
                station.logger.warn ({
                    domain:     self.domain,
                    action:     self.name,
                    forward:    self.config.forward,
                    status:     agentStatus
                }, 'unknown agent status requested');
                reply.done (502);
                return;
            }

            if (
                !user.length
             || user.length > 128
             || !client.length
             || client.length > 128
            ) {
                station.logger.warn ({
                    domain:     self.domain,
                    action:     self.name,
                    forward:    self.config.forward,
                    status:     agentStatus
                }, 'agent headers incomplete');
                reply.done (502);
                return;
            }

            agent[callName] (user, client, rememberMe, finalize);
            return;
        }

        finalize();
    });

    remoteRequest.method = request.method;
    remoteRequest.setHeader ('X-Substation-Action', this.config.name || '');
    remoteRequest.setHeader ('X-Substation-Format', request.format);

    if (agent.user) {
        remoteRequest.setHeader ('X-Substation-User', agent.user);
        remoteRequest.setHeader ('X-Substation-Client', agent.client);
    }
    if (agent.isLoggedIn)
        remoteRequest.setHeader ('X-Substation-Active', 'yes');
    if (agent.isDomestic)
        remoteRequest.setHeader ('X-Substation-Domestic', 'yes');

    if (request.stream) {
        remoteRequest.setHeader ('X-Substation-Binary', 'yes');
        remoteRequest.setHeader ('Content-Type', request.contentType);
        request.stream.pipe (remoteRequest);
        return;
    }

    remoteRequest.setHeader ('Content-Type', 'application/json');
    remoteRequest.on ('error', function (err) {
        station.logger.warn ({ err:err, action:this.name }, 'failed to forward an action');
        reply.done (502);
    });

    // forward to the remote server for processing
    var exportStr = JSON.stringify ({
        query:  request.query,
        body:   request.body,
        params: request.params
    });
    remoteRequest.setHeader ('Content-Length', Buffer.byteLength (exportStr));
    remoteRequest.write (exportStr);
    remoteRequest.end();
};


/**     @struct Configuration
    Configuration options for [Actions](.).
@member/JSON authentication
    Specify a minimum authentication profile to access this Action. Unauthenticated requests are
    automatically served a blank 403 response.

    @property authentication.loggedIn
    @property authentication.domestic
@member/Function|Object template
    When a client uses this Action over the REST transport, a template will be executed if it is
    supplied. Specify either a single template Function or a map of response codes to template
    Functions. Wildcards may be used i.e. "2xx" or "30x". Most specific response code wins.

    @argument/Object template(context
        The template's execution context, i.e. the document to render to html.
    @callback template(callback
        @optional
        If the template does not return a String, `substation` will wait for this callback.
        @argument/Error|undefined err
        @argument/String html
            Rendered html output.
        @returns
    @returns/String|undefined template)html
        Synchronous templates may return their rendered content immediately and ignore the callback.
@member/Boolean binaryStreams
    @default `false`
    If true, accept unknown content types and pass them, as well as `multipart/form-data` requests,
    to the Action as streams. The passed `request.body` will be a `ReadableStream` instance.
@member/Boolean neverBuffer
    @default `false`
    When [binaryStreams](#binaryStreams) is set and so is `neverBuffer`, the [request body]
    (.Request.body) is always a [stream](streams.ReadableStream).
@member/Number bufferFiles
    @default `64000`
    Prebuffer trivial files into memory, up to the given number of bytes across all uploaded files.
    Handy for handling small file uploads (such as user avatars) in an application where file
    uploads are not a significant feature.
@member/
*/
var DEFAULT_CONFIG = {
    binaryStreams:  false,
    neverBuffer:    false,
    bufferFiles:    64000,
    maxBodyLength:  40960
};


/**     @member/Function setup
    First of two calls used to prepare Actions to [run](#run). Calls any configured [setup]
    (.Configuration#setup) Function. Schemata are submitted to `likeness` at this point but not
    compiled until [ready](#ready) is called.
@callback
*/
Action.prototype.setup = function (station, schemaContext, callback) {
    var self = this;

    if (this.config.setup)
        return this.config.setup.call (station, this.config, function (err) {
            async.parallel ([
                function (callback) {
                    if (!self.config.bodySchema)
                        return callback();
                    self.bodySchemaExport = self.config.bodySchema;
                    schemaContext.submit (self.config.bodySchema, callback);
                },
                function (callback) {
                    if (!self.config.querySchema)
                        return callback();
                    self.querySchemaExport = self.config.querySchema;
                    schemaContext.submit (self.config.querySchema, callback);
                }
            ], callback);
        });

    async.parallel ([
        function (callback) {
            if (self.config.bodySchema)
                schemaContext.submit (self.config.bodySchema, callback);
            else
                callback();
        },
        function (callback) {
            if (self.config.querySchema)
                schemaContext.submit (self.config.querySchema, callback);
            else
                callback();
        }
    ], callback);
};


/**     @member/Function ready

*/
Action.prototype.ready = function (schemaContext, callback) {
    var self = this;
    async.parallel ([
        function (callback) {
            if (!self.config.bodySchema)
                return callback();
            self.originalBodySchema = self.config.bodySchema;
            schemaContext.compile (self.config.bodySchema, function (err, compiled, metaschema) {
                if (err) return callback (err);
                self.compiledBodySchema = compiled;
                likeness.helpers.fromJSONSchema (metaschema, compiled, function (err, likeDoc) {
                    if (err) return callback (err);
                    var schema;
                    try {
                        schema = new likeness (likeDoc);
                        self.bodySchema = schema;
                    } catch (err) {
                        return callback (err);
                    }
                    callback();
                });
            });
        },
        function (callback) {
            if (!self.config.querySchema)
                return callback();
            self.originalQuerySchema = self.config.querySchema;
            schemaContext.compile (self.config.querySchema, function (err, compiled, metaschema) {
                if (err) return callback (err);
                self.compiledQuerySchema = compiled;
                likeness.helpers.fromJSONSchema (metaschema, compiled, function (err, likeDoc) {
                    if (err) return callback (err);
                    var schema;
                    try {
                        schema = new likeness (likeDoc);
                        self.querySchema = schema;
                        return callback();
                    } catch (err) {
                        return callback (err);
                    }
                });
            });
        }
    ], callback);
};


/**     @member/Function toHTML

*/
Action.prototype.toHTML = function (station, status, context, callback) {
    console.log ('toHTML?!');
    process.nextTick (callback);
};


module.exports = Action;
